"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const nodePath = require("path");
const errors = require("../errors");
const utils_1 = require("../utils");
class DefaultFileSystemHost {
    constructor() {
        // Prevent "fs-extra" and "globby" from being loaded in environments that don't support it (ex. browsers).
        // This means if someone specifies to use a virtual file system then it won't load this.
        this.fs = require("fs-extra");
        this.globby = require("globby");
    }
    delete(path) {
        return new Promise((resolve, reject) => {
            this.fs.unlink(path, err => {
                if (err)
                    reject(this.getFileNotFoundErrorIfNecessary(err, path));
                else
                    resolve();
            });
        });
    }
    deleteSync(path) {
        try {
            this.fs.unlinkSync(path);
        }
        catch (err) {
            throw this.getFileNotFoundErrorIfNecessary(err, path);
        }
    }
    readDirSync(dirPath) {
        try {
            return this.fs.readdirSync(dirPath).map(name => utils_1.FileUtils.pathJoin(dirPath, name));
        }
        catch (err) {
            throw this.getDirectoryNotFoundErrorIfNecessary(err, dirPath);
        }
    }
    readFile(filePath, encoding = "utf-8") {
        return new Promise((resolve, reject) => {
            this.fs.readFile(filePath, encoding, (err, data) => {
                if (err)
                    reject(this.getFileNotFoundErrorIfNecessary(err, filePath));
                else
                    resolve(data);
            });
        });
    }
    readFileSync(filePath, encoding = "utf-8") {
        try {
            return this.fs.readFileSync(filePath, encoding);
        }
        catch (err) {
            throw this.getFileNotFoundErrorIfNecessary(err, filePath);
        }
    }
    writeFile(filePath, fileText) {
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve, reject) => {
                this.fs.writeFile(filePath, fileText, err => {
                    if (err)
                        reject(err);
                    else
                        resolve();
                });
            });
        });
    }
    writeFileSync(filePath, fileText) {
        this.fs.writeFileSync(filePath, fileText);
    }
    mkdir(dirPath) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.fs.mkdirp(dirPath);
            }
            catch (err) {
                // ignore if it already exists
                if (err.code !== "EEXIST")
                    throw err;
            }
        });
    }
    mkdirSync(dirPath) {
        try {
            this.fs.mkdirpSync(dirPath);
        }
        catch (err) {
            // ignore if it already exists
            if (err.code !== "EEXIST")
                throw err;
        }
    }
    move(srcPath, destPath) {
        return this.fs.move(srcPath, destPath, { overwrite: true });
    }
    moveSync(srcPath, destPath) {
        this.fs.moveSync(srcPath, destPath, { overwrite: true });
    }
    copy(srcPath, destPath) {
        return this.fs.copy(srcPath, destPath, { overwrite: true });
    }
    copySync(srcPath, destPath) {
        this.fs.copySync(srcPath, destPath, { overwrite: true });
    }
    fileExists(filePath) {
        return new Promise(resolve => {
            this.fs.stat(filePath, (err, stat) => {
                if (err)
                    resolve(false);
                else
                    resolve(stat.isFile());
            });
        });
    }
    fileExistsSync(filePath) {
        try {
            return this.fs.statSync(filePath).isFile();
        }
        catch (err) {
            return false;
        }
    }
    directoryExists(dirPath) {
        return new Promise(resolve => {
            this.fs.stat(dirPath, (err, stat) => {
                if (err)
                    resolve(false);
                else
                    resolve(stat.isDirectory());
            });
        });
    }
    directoryExistsSync(dirPath) {
        try {
            return this.fs.statSync(dirPath).isDirectory();
        }
        catch (err) {
            return false;
        }
    }
    realpathSync(path) {
        return this.fs.realpathSync(path);
    }
    getCurrentDirectory() {
        return utils_1.FileUtils.standardizeSlashes(nodePath.resolve());
    }
    glob(patterns) {
        // convert backslashes to foward
        patterns = patterns.map(p => p.replace(/\\/g, "/")); // maybe this isn't full-proof?
        return this.globby.sync(patterns, {
            cwd: this.getCurrentDirectory(),
            absolute: true
        });
    }
    isCaseSensitive() {
        const platform = process.platform;
        return platform !== "win32" && platform !== "darwin";
    }
    getDirectoryNotFoundErrorIfNecessary(err, path) {
        return utils_1.FileUtils.isNotExistsError(err) ? new errors.DirectoryNotFoundError(path) : err;
    }
    getFileNotFoundErrorIfNecessary(err, path) {
        return utils_1.FileUtils.isNotExistsError(err) ? new errors.FileNotFoundError(path) : err;
    }
}
exports.DefaultFileSystemHost = DefaultFileSystemHost;

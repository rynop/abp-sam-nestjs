"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const compiler_1 = require("../compiler");
const errors = require("../errors");
const typescript_1 = require("../typescript");
const utils_1 = require("../utils");
const DirectoryEmitResult_1 = require("./DirectoryEmitResult");
class Directory {
    /** @private */
    constructor(context, path) {
        this.__context = context;
        this._setPathInternal(path);
    }
    /** @internal */
    _setPathInternal(path) {
        this._path = path;
        this._pathParts = path.split("/").filter(p => p.length > 0);
    }
    /** @internal */
    get _context() {
        this._throwIfDeletedOrRemoved();
        return this.__context;
    }
    /**
     * Checks if this directory is an ancestor of the provided directory.
     * @param possibleDescendant - Directory or source file that's a possible descendant.
     */
    isAncestorOf(possibleDescendant) {
        return Directory._isAncestorOfDir(this, possibleDescendant);
    }
    /**
     * Checks if this directory is a descendant of the provided directory.
     * @param possibleAncestor - Directory or source file that's a possible ancestor.
     */
    isDescendantOf(possibleAncestor) {
        return Directory._isAncestorOfDir(possibleAncestor, this);
    }
    /**
     * Gets the directory depth.
     * @internal
     */
    _getDepth() {
        return this._pathParts.length;
    }
    /**
     * Gets the path to the directory.
     */
    getPath() {
        this._throwIfDeletedOrRemoved();
        return this._path;
    }
    /**
     * Gets the directory path's base name.
     */
    getBaseName() {
        return this._pathParts[this._pathParts.length - 1];
    }
    /**
     * Gets the parent directory or throws if it doesn't exist or was never added to the project.
     */
    getParentOrThrow() {
        return errors.throwIfNullOrUndefined(this.getParent(), () => `Parent directory of ${this.getPath()} does not exist or was never added.`);
    }
    /**
     * Gets the parent directory if it exists and was added to the project.
     */
    getParent() {
        if (utils_1.FileUtils.isRootDirPath(this.getPath()))
            return undefined;
        return this.addExistingDirectoryIfExists(utils_1.FileUtils.getDirPath(this.getPath()));
    }
    getDirectoryOrThrow(pathOrCondition) {
        return errors.throwIfNullOrUndefined(this.getDirectory(pathOrCondition), () => {
            if (typeof pathOrCondition === "string")
                return `Could not find a directory at path '${this._context.fileSystemWrapper.getStandardizedAbsolutePath(pathOrCondition, this.getPath())}'.`;
            return "Could not find child directory that matched condition.";
        });
    }
    getDirectory(pathOrCondition) {
        if (typeof pathOrCondition === "string") {
            const path = this._context.fileSystemWrapper.getStandardizedAbsolutePath(pathOrCondition, this.getPath());
            return this._context.compilerFactory.getDirectoryFromCache(path);
        }
        return this.getDirectories().find(pathOrCondition);
    }
    getSourceFileOrThrow(pathOrCondition) {
        return errors.throwIfNullOrUndefined(this.getSourceFile(pathOrCondition), () => {
            if (typeof pathOrCondition === "string")
                return `Could not find child source file at path '${this._context.fileSystemWrapper.getStandardizedAbsolutePath(pathOrCondition, this.getPath())}'.`;
            return "Could not find child source file that matched condition.";
        });
    }
    getSourceFile(pathOrCondition) {
        if (typeof pathOrCondition === "string") {
            const path = this._context.fileSystemWrapper.getStandardizedAbsolutePath(pathOrCondition, this.getPath());
            return this._context.compilerFactory.getSourceFileFromCacheFromFilePath(path);
        }
        return this.getSourceFiles().find(pathOrCondition);
    }
    /**
     * Gets the child directories.
     */
    getDirectories() {
        return this._context.compilerFactory.getChildDirectoriesOfDirectory(this.getPath());
    }
    /**
     * Gets the source files within this directory.
     */
    getSourceFiles() {
        return this._context.compilerFactory.getChildSourceFilesOfDirectory(this.getPath());
    }
    /**
     * Gets the source files in the current directory and all the descendant directories.
     */
    getDescendantSourceFiles() {
        return Array.from(this._getDescendantSourceFilesIterator());
    }
    /**
     * Gets the source files in the current directory and all the descendant directories.
     * @internal
     */
    *_getDescendantSourceFilesIterator() {
        for (const sourceFile of this.getSourceFiles())
            yield sourceFile;
        for (const directory of this.getDirectories())
            yield* directory._getDescendantSourceFilesIterator();
    }
    /**
     * Gets the descendant directories.
     */
    getDescendantDirectories() {
        return Array.from(this._getDescendantDirectoriesIterator());
    }
    /**
     * Gets the descendant directories.
     * @internal
     */
    *_getDescendantDirectoriesIterator() {
        for (const directory of this.getDirectories()) {
            yield directory;
            yield* directory._getDescendantDirectoriesIterator();
        }
    }
    /**
     * Add source files based on file globs.
     * @param fileGlobs - File glob or globs to add files based on.
     * @returns The matched source files.
     */
    addExistingSourceFiles(fileGlobs) {
        fileGlobs = typeof fileGlobs === "string" ? [fileGlobs] : fileGlobs;
        fileGlobs = fileGlobs.map(g => {
            if (utils_1.FileUtils.pathIsAbsolute(g))
                return g;
            return utils_1.FileUtils.pathJoin(this.getPath(), g);
        });
        return this._context.directoryCoordinator.addExistingSourceFiles(fileGlobs, { markInProject: this._isInProject() });
    }
    /**
     * Adds an existing directory from the relative path or directory name, or returns undefined if it doesn't exist.
     *
     * Will return the directory if it was already added.
     * @param dirPath - Directory name or path to the directory that should be added.
     * @param options - Options.
     * @skipOrThrowCheck
     */
    addExistingDirectoryIfExists(dirPath, options = {}) {
        dirPath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath, this.getPath());
        return this._context.directoryCoordinator.addExistingDirectoryIfExists(dirPath, Object.assign({}, options, { markInProject: this._isInProject() }));
    }
    /**
     * Adds an existing directory from the relative path or directory name, or throws if it doesn't exist.
     *
     * Will return the directory if it was already added.
     * @param dirPath - Directory name or path to the directory that should be added.
     * @throws DirectoryNotFoundError if the directory does not exist.
     */
    addExistingDirectory(dirPath, options = {}) {
        dirPath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath, this.getPath());
        return this._context.directoryCoordinator.addExistingDirectory(dirPath, Object.assign({}, options, { markInProject: this._isInProject() }));
    }
    /**
     * Creates a directory if it doesn't exist.
     * @param dirPath - Relative or absolute path to the directory that should be created.
     */
    createDirectory(dirPath) {
        dirPath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath, this.getPath());
        return this._context.directoryCoordinator.createDirectoryOrAddIfExists(dirPath, { markInProject: this._isInProject() });
    }
    /**
     * Creates a source file, relative to this directory.
     *
     * Note: The file will not be created and saved to the file system until .save() is called on the source file.
     * @param relativeFilePath - Relative file path of the source file to create.
     * @param sourceFileText - Text, structure, or writer function to create the source file text with.
     * @param options - Options.
     * @throws - InvalidOperationError if a source file already exists at the provided file name.
     */
    createSourceFile(relativeFilePath, sourceFileText, options) {
        const filePath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(relativeFilePath, this.getPath());
        return this._context.compilerFactory.createSourceFile(filePath, sourceFileText || "", Object.assign({}, (options || {}), { markInProject: this._isInProject() }));
    }
    /**
     * Adds an existing source file, relative to this directory, or returns undefined.
     *
     * Will return the source file if it was already added.
     * @param relativeFilePath - Relative file path to add.
     * @skipOrThrowCheck
     */
    addExistingSourceFileIfExists(relativeFilePath) {
        const filePath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(relativeFilePath, this.getPath());
        return this._context.directoryCoordinator.addExistingSourceFileIfExists(filePath, { markInProject: this._isInProject() });
    }
    /**
     * Adds an existing source file, relative to this directory, or throws if it doesn't exist.
     *
     * Will return the source file if it was already added.
     * @param relativeFilePath - Relative file path to add.
     * @throws FileNotFoundError when the file doesn't exist.
     */
    addExistingSourceFile(relativeFilePath) {
        const filePath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(relativeFilePath, this.getPath());
        return this._context.directoryCoordinator.addExistingSourceFile(filePath, { markInProject: this._isInProject() });
    }
    /**
     * Emits the files in the directory.
     * @param options - Options for emitting.
     */
    emit(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { fileSystemWrapper } = this._context;
            const writeTasks = [];
            const outputFilePaths = [];
            const skippedFilePaths = [];
            for (const emitResult of this._emitInternal(options)) {
                if (typeof emitResult === "string")
                    skippedFilePaths.push(emitResult);
                else {
                    writeTasks.push(fileSystemWrapper.writeFile(emitResult.filePath, emitResult.fileText));
                    outputFilePaths.push(emitResult.filePath);
                }
            }
            yield Promise.all(writeTasks);
            return new DirectoryEmitResult_1.DirectoryEmitResult(skippedFilePaths, outputFilePaths);
        });
    }
    /**
     * Emits the files in the directory synchronously.
     *
     * Remarks: This might be very slow compared to the asynchronous version if there are a lot of files.
     * @param options - Options for emitting.
     */
    emitSync(options = {}) {
        const { fileSystemWrapper } = this._context;
        const outputFilePaths = [];
        const skippedFilePaths = [];
        for (const emitResult of this._emitInternal(options)) {
            if (typeof emitResult === "string")
                skippedFilePaths.push(emitResult);
            else {
                fileSystemWrapper.writeFileSync(emitResult.filePath, emitResult.fileText);
                outputFilePaths.push(emitResult.filePath);
            }
        }
        return new DirectoryEmitResult_1.DirectoryEmitResult(skippedFilePaths, outputFilePaths);
    }
    _emitInternal(options = {}) {
        const { emitOnlyDtsFiles = false } = options;
        const isJsFile = options.outDir == null ? undefined : /\.js$/i;
        const isMapFile = options.outDir == null ? undefined : /\.js\.map$/i;
        const isDtsFile = options.declarationDir == null && options.outDir == null ? undefined : /\.d\.ts$/i;
        const getStandardizedPath = (path) => path == null ? undefined : this._context.fileSystemWrapper.getStandardizedAbsolutePath(path, this.getPath());
        const getSubDirPath = (path, dir) => path == null ? undefined : utils_1.FileUtils.pathJoin(path, dir.getBaseName());
        const hasDeclarationDir = this._context.compilerOptions.get().declarationDir != null || options.declarationDir != null;
        return emitDirectory(this, getStandardizedPath(options.outDir), getStandardizedPath(options.declarationDir));
        function* emitDirectory(directory, outDir, declarationDir) {
            for (const sourceFile of directory.getSourceFiles()) {
                const output = sourceFile.getEmitOutput({ emitOnlyDtsFiles });
                if (output.getEmitSkipped()) {
                    yield sourceFile.getFilePath();
                    continue;
                }
                for (const outputFile of output.getOutputFiles()) {
                    let filePath = outputFile.getFilePath();
                    const fileText = outputFile.getWriteByteOrderMark() ? utils_1.FileUtils.getTextWithByteOrderMark(outputFile.getText()) : outputFile.getText();
                    if (outDir != null && (isJsFile.test(filePath) || isMapFile.test(filePath) || (!hasDeclarationDir && isDtsFile.test(filePath))))
                        filePath = utils_1.FileUtils.pathJoin(outDir, utils_1.FileUtils.getBaseName(filePath));
                    else if (declarationDir != null && isDtsFile.test(filePath))
                        filePath = utils_1.FileUtils.pathJoin(declarationDir, utils_1.FileUtils.getBaseName(filePath));
                    yield { filePath, fileText };
                }
            }
            for (const dir of directory.getDirectories())
                yield* emitDirectory(dir, getSubDirPath(outDir, dir), getSubDirPath(declarationDir, dir));
        }
    }
    /**
     * Copies the directory to a subdirectory of the specified directory.
     * @param dirPathOrDirectory Directory path or directory object to copy the directory to.
     * @param options Options for copying.
     * @returns The new copied directory.
     */
    copyToDirectory(dirPathOrDirectory, options) {
        const dirPath = typeof dirPathOrDirectory === "string" ? dirPathOrDirectory : dirPathOrDirectory.getPath();
        return this.copy(utils_1.FileUtils.pathJoin(dirPath, this.getBaseName()), options);
    }
    /**
     * Copies the directory to a new directory.
     * @param relativeOrAbsolutePath - The relative or absolute path to the new directory.
     * @param options - Options.
     * @returns The directory the copy was made to.
     */
    copy(relativeOrAbsolutePath, options) {
        const originalPath = this.getPath();
        const fileSystem = this._context.fileSystemWrapper;
        const newPath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(relativeOrAbsolutePath, this.getPath());
        if (originalPath === newPath)
            return this;
        options = getDirectoryCopyOptions(options);
        if (options.includeUntrackedFiles)
            fileSystem.queueCopyDirectory(originalPath, newPath);
        return this._copyInternal(newPath, options);
    }
    /**
     * Immediately copies the directory to the specified path asynchronously.
     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.
     * @param options - Options for moving the directory.
     * @remarks If includeTrackedFiles is true, then it will execute the pending operations in the current directory.
     */
    copyImmediately(relativeOrAbsolutePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileSystem = this._context.fileSystemWrapper;
            const originalPath = this.getPath();
            const newPath = fileSystem.getStandardizedAbsolutePath(relativeOrAbsolutePath, originalPath);
            if (originalPath === newPath) {
                yield this.save();
                return this;
            }
            options = getDirectoryCopyOptions(options);
            const newDir = this._copyInternal(newPath, options);
            if (options.includeUntrackedFiles)
                yield fileSystem.copyDirectoryImmediately(originalPath, newPath);
            yield newDir.save();
            return newDir;
        });
    }
    /**
     * Immediately copies the directory to the specified path synchronously.
     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.
     * @param options - Options for moving the directory.
     * @remarks If includeTrackedFiles is true, then it will execute the pending operations in the current directory.
     */
    copyImmediatelySync(relativeOrAbsolutePath, options) {
        const fileSystem = this._context.fileSystemWrapper;
        const originalPath = this.getPath();
        const newPath = fileSystem.getStandardizedAbsolutePath(relativeOrAbsolutePath, originalPath);
        if (originalPath === newPath) {
            this.saveSync();
            return this;
        }
        options = getDirectoryCopyOptions(options);
        const newDir = this._copyInternal(newPath, options);
        if (options.includeUntrackedFiles)
            fileSystem.copyDirectoryImmediatelySync(originalPath, newPath);
        newDir.saveSync();
        return newDir;
    }
    /** @internal */
    _copyInternal(newPath, options) {
        const originalPath = this.getPath();
        if (originalPath === newPath)
            return this;
        const { fileSystemWrapper: fileSystem, compilerFactory } = this._context;
        const copyingDirectories = [this, ...this.getDescendantDirectories()].map(directory => ({
            newDirPath: directory === this ? newPath : fileSystem.getStandardizedAbsolutePath(this.getRelativePathTo(directory), newPath)
        }));
        const copyingSourceFiles = this.getDescendantSourceFiles().map(sourceFile => ({
            sourceFile,
            newFilePath: fileSystem.getStandardizedAbsolutePath(this.getRelativePathTo(sourceFile), newPath),
            references: this._getReferencesForCopy(sourceFile)
        }));
        // copy directories
        for (const { newDirPath } of copyingDirectories)
            this._context.compilerFactory.createDirectoryOrAddIfExists(newDirPath, { markInProject: this._isInProject() });
        // copy source files
        for (const { sourceFile, newFilePath } of copyingSourceFiles)
            sourceFile._copyInternal(newFilePath, options);
        // update the references
        for (const { references, newFilePath } of copyingSourceFiles)
            this.getSourceFileOrThrow(newFilePath)._updateReferencesForCopyInternal(references);
        return compilerFactory.getDirectoryFromCache(newPath);
    }
    /**
     * Moves the directory to a subdirectory of the specified directory.
     * @param dirPathOrDirectory Directory path or directory object to move the directory to.
     * @param options Options for moving.
     */
    moveToDirectory(dirPathOrDirectory, options) {
        const dirPath = typeof dirPathOrDirectory === "string" ? dirPathOrDirectory : dirPathOrDirectory.getPath();
        return this.move(utils_1.FileUtils.pathJoin(dirPath, this.getBaseName()), options);
    }
    /**
     * Moves the directory to a new path.
     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.
     * @param options - Options for moving the directory.
     */
    move(relativeOrAbsolutePath, options) {
        const fileSystem = this._context.fileSystemWrapper;
        const originalPath = this.getPath();
        const newPath = fileSystem.getStandardizedAbsolutePath(relativeOrAbsolutePath, originalPath);
        if (originalPath === newPath)
            return this;
        return this._moveInternal(newPath, options, () => fileSystem.queueMoveDirectory(originalPath, newPath));
    }
    /**
     * Immediately moves the directory to a new path asynchronously.
     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.
     * @param options - Options for moving the directory.
     */
    moveImmediately(relativeOrAbsolutePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileSystem = this._context.fileSystemWrapper;
            const originalPath = this.getPath();
            const newPath = fileSystem.getStandardizedAbsolutePath(relativeOrAbsolutePath, originalPath);
            if (originalPath === newPath) {
                yield this.save();
                return this;
            }
            this._moveInternal(newPath, options);
            yield fileSystem.moveDirectoryImmediately(originalPath, newPath);
            yield this.save();
            return this;
        });
    }
    /**
     * Immediately moves the directory to a new path synchronously.
     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.
     * @param options - Options for moving the directory.
     */
    moveImmediatelySync(relativeOrAbsolutePath, options) {
        const fileSystem = this._context.fileSystemWrapper;
        const originalPath = this.getPath();
        const newPath = fileSystem.getStandardizedAbsolutePath(relativeOrAbsolutePath, originalPath);
        if (originalPath === newPath) {
            this.saveSync();
            return this;
        }
        this._moveInternal(newPath, options);
        fileSystem.moveDirectoryImmediatelySync(originalPath, newPath);
        this.saveSync();
        return this;
    }
    /** @internal */
    _moveInternal(newPath, options, preAction) {
        const originalPath = this.getPath();
        if (originalPath === newPath)
            return this;
        const existingDir = this._context.compilerFactory.getDirectoryFromCacheOnlyIfInCache(newPath);
        const markInProject = existingDir != null && existingDir._isInProject();
        if (preAction)
            preAction();
        const fileSystem = this._context.fileSystemWrapper;
        const compilerFactory = this._context.compilerFactory;
        const movingDirectories = [this, ...this.getDescendantDirectories()].map(directory => ({
            directory,
            oldPath: directory.getPath(),
            newDirPath: directory === this ? newPath : fileSystem.getStandardizedAbsolutePath(this.getRelativePathTo(directory), newPath)
        }));
        const movingSourceFiles = this.getDescendantSourceFiles().map(sourceFile => ({
            sourceFile,
            newFilePath: fileSystem.getStandardizedAbsolutePath(this.getRelativePathTo(sourceFile), newPath),
            references: this._getReferencesForMove(sourceFile)
        }));
        // update directories
        for (const { directory, oldPath, newDirPath } of movingDirectories) {
            compilerFactory.removeDirectoryFromCache(oldPath);
            const dirToOverwrite = compilerFactory.getDirectoryFromCache(newDirPath);
            if (dirToOverwrite != null)
                dirToOverwrite._forgetOnlyThis();
            directory._setPathInternal(newDirPath);
            compilerFactory.addDirectoryToCache(directory);
        }
        // update source files
        for (const { sourceFile, newFilePath } of movingSourceFiles)
            sourceFile._moveInternal(newFilePath, options);
        // update the references
        for (const { sourceFile, references } of movingSourceFiles)
            sourceFile._updateReferencesForMoveInternal(references, originalPath);
        // mark as in the project last to ensure the previous ancestor dirs aren't marked in the project as well
        if (markInProject)
            this._markAsInProject();
        return this;
    }
    /**
     * Queues a deletion of the directory to the file system.
     *
     * The directory will be deleted when calling ast.save(). If you wish to delete the file immediately, then use deleteImmediately().
     */
    delete() {
        const { fileSystemWrapper } = this._context;
        const path = this.getPath();
        for (const sourceFile of this.getSourceFiles())
            sourceFile.delete();
        for (const dir of this.getDirectories())
            dir.delete();
        fileSystemWrapper.queueDirectoryDelete(path);
        this.forget();
    }
    /**
     * Asyncronously deletes the directory and all its descendants from the file system.
     */
    deleteImmediately() {
        return __awaiter(this, void 0, void 0, function* () {
            const { fileSystemWrapper } = this._context;
            const path = this.getPath();
            this.forget();
            yield fileSystemWrapper.deleteDirectoryImmediately(path);
        });
    }
    /**
     * Synchronously deletes the directory and all its descendants from the file system.
     */
    deleteImmediatelySync() {
        const { fileSystemWrapper } = this._context;
        const path = this.getPath();
        this.forget();
        fileSystemWrapper.deleteDirectoryImmediatelySync(path);
    }
    /**
     * Forgets the directory and all its descendants from the Project.
     *
     * Note: Does not delete the directory from the file system.
     */
    forget() {
        if (this.wasForgotten())
            return;
        for (const sourceFile of this.getSourceFiles())
            sourceFile.forget();
        for (const dir of this.getDirectories())
            dir.forget();
        this._forgetOnlyThis();
    }
    /** @internal */
    _forgetOnlyThis() {
        if (this.wasForgotten())
            return;
        this._context.compilerFactory.removeDirectoryFromCache(this.getPath());
        this.__context = undefined;
    }
    /**
     * Asynchronously saves the directory and all the unsaved source files to the disk.
     */
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._context.fileSystemWrapper.saveForDirectory(this.getPath());
            const unsavedSourceFiles = this.getDescendantSourceFiles().filter(s => !s.isSaved());
            yield Promise.all(unsavedSourceFiles.map(s => s.save()));
        });
    }
    /**
     * Synchronously saves the directory and all the unsaved source files to the disk.
     */
    saveSync() {
        this._context.fileSystemWrapper.saveForDirectorySync(this.getPath());
        const unsavedSourceFiles = this.getDescendantSourceFiles().filter(s => !s.isSaved());
        unsavedSourceFiles.forEach(s => s.saveSync());
    }
    getRelativePathTo(sourceFileOrDir) {
        return utils_1.FileUtils.getRelativePathTo(this.getPath(), getPath());
        function getPath() {
            return sourceFileOrDir instanceof compiler_1.SourceFile ? sourceFileOrDir.getFilePath() : sourceFileOrDir.getPath();
        }
    }
    getRelativePathAsModuleSpecifierTo(sourceFileOrDir) {
        const moduleResolution = this._context.program.getEmitModuleResolutionKind();
        const thisDirectory = this;
        const moduleSpecifier = utils_1.FileUtils.getRelativePathTo(this.getPath(), getPath()).replace(/((\.d\.ts$)|(\.[^/.]+$))/i, "");
        return moduleSpecifier.startsWith("../") ? moduleSpecifier : "./" + moduleSpecifier;
        function getPath() {
            return sourceFileOrDir instanceof compiler_1.SourceFile ? getPathForSourceFile(sourceFileOrDir) : getPathForDirectory(sourceFileOrDir);
            function getPathForSourceFile(sourceFile) {
                switch (moduleResolution) {
                    case typescript_1.ModuleResolutionKind.NodeJs:
                        const filePath = sourceFile.getFilePath();
                        if (sourceFile.getDirectory() === thisDirectory)
                            return filePath;
                        return filePath.replace(/\/index?(\.d\.ts|\.ts|\.js)$/i, "");
                    case typescript_1.ModuleResolutionKind.Classic:
                        return sourceFile.getFilePath();
                    default:
                        return errors.throwNotImplementedForNeverValueError(moduleResolution);
                }
            }
            function getPathForDirectory(dir) {
                switch (moduleResolution) {
                    case typescript_1.ModuleResolutionKind.NodeJs:
                        if (dir === thisDirectory)
                            return utils_1.FileUtils.pathJoin(dir.getPath(), "index.ts");
                        return dir.getPath();
                    case typescript_1.ModuleResolutionKind.Classic:
                        return utils_1.FileUtils.pathJoin(dir.getPath(), "index.ts");
                    default:
                        return errors.throwNotImplementedForNeverValueError(moduleResolution);
                }
            }
        }
    }
    /**
     * Gets if the directory was forgotten.
     */
    wasForgotten() {
        return this.__context == null;
    }
    /** @internal */
    _isInProject() {
        return this._context.inProjectCoordinator.isDirectoryInProject(this);
    }
    /** @internal */
    _markAsInProject() {
        this._context.inProjectCoordinator.markDirectoryAsInProject(this);
    }
    /** @internal */
    _hasLoadedParent() {
        return this._context.compilerFactory.containsDirectoryAtPath(utils_1.FileUtils.getDirPath(this.getPath()));
    }
    /** @internal */
    _throwIfDeletedOrRemoved() {
        if (this.wasForgotten())
            throw new errors.InvalidOperationError("Cannot use a directory that was deleted, removed, or overwritten.");
    }
    /** @internal */
    _getReferencesForCopy(sourceFile) {
        const literalReferences = sourceFile._getReferencesForCopyInternal();
        return literalReferences.filter(r => !this.isAncestorOf(r[1]));
    }
    /** @internal */
    _getReferencesForMove(sourceFile) {
        const { literalReferences, referencingLiterals } = sourceFile._getReferencesForMoveInternal();
        return {
            literalReferences: literalReferences.filter(r => !this.isAncestorOf(r[1])),
            referencingLiterals: referencingLiterals.filter(l => !this.isAncestorOf(l._sourceFile))
        };
    }
    /** @internal */
    static _isAncestorOfDir(ancestor, descendant) {
        if (descendant instanceof compiler_1.SourceFile) {
            descendant = descendant.getDirectory();
            if (ancestor === descendant)
                return true;
        }
        if (ancestor._pathParts.length >= descendant._pathParts.length)
            return false;
        // more likely to be a mistake at the end, so search backwards
        for (let i = ancestor._pathParts.length - 1; i >= 0; i--) {
            if (ancestor._pathParts[i] !== descendant._pathParts[i])
                return false;
        }
        return true;
    }
}
exports.Directory = Directory;
function getDirectoryCopyOptions(options) {
    options = utils_1.ObjectUtils.clone(options || {});
    utils_1.setValueIfUndefined(options, "includeUntrackedFiles", true);
    return options;
}

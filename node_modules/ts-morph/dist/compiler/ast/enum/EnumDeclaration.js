"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../../../errors");
const manipulation_1 = require("../../../manipulation");
const structures_1 = require("../../../structures");
const typescript_1 = require("../../../typescript");
const utils_1 = require("../../../utils");
const base_1 = require("../base");
const callBaseSet_1 = require("../callBaseSet");
const module_1 = require("../module");
const statement_1 = require("../statement");
const callBaseGetStructure_1 = require("../callBaseGetStructure");
const utils_2 = require("../utils");
exports.EnumDeclarationBase = base_1.TextInsertableNode(module_1.NamespaceChildableNode(base_1.JSDocableNode(base_1.AmbientableNode(base_1.ExportableNode(base_1.ModifierableNode(base_1.NamedNode(statement_1.Statement)))))));
class EnumDeclaration extends exports.EnumDeclarationBase {
    /**
     * Sets the node from a structure.
     * @param structure - Structure to set the node with.
     */
    set(structure) {
        callBaseSet_1.callBaseSet(exports.EnumDeclarationBase.prototype, this, structure);
        if (structure.isConst != null)
            this.setIsConstEnum(structure.isConst);
        if (structure.members != null) {
            this.getMembers().forEach(m => m.remove());
            this.addMembers(structure.members);
        }
        return this;
    }
    addMember(structure) {
        return this.addMembers([structure])[0];
    }
    addMembers(structures) {
        return this.insertMembers(this.getMembers().length, structures);
    }
    insertMember(index, structure) {
        return this.insertMembers(index, [structure])[0];
    }
    insertMembers(index, structures) {
        if (structures.length === 0)
            return [];
        const members = this.getMembersWithComments();
        index = manipulation_1.verifyAndGetIndex(index, members.length);
        // create member code
        // todo: pass in the StructureToText to the function below
        const writer = this._getWriterWithChildIndentation();
        const structurePrinter = this._context.structurePrinterFactory.forEnumMember();
        structurePrinter.printTexts(writer, structures);
        // insert
        manipulation_1.insertIntoCommaSeparatedNodes({
            parent: this.getChildSyntaxListOrThrow(),
            currentNodes: members,
            insertIndex: index,
            newText: writer.toString(),
            useNewLines: true
        });
        // get the members
        return manipulation_1.getNodesToReturn(members, this.getMembersWithComments(), index, !areAllStructuresStructures());
        function areAllStructuresStructures() {
            // if every item is a structure
            if (!(structures instanceof Array))
                return false;
            return structures.every(s => typeof s === "object");
        }
    }
    getMember(nameOrFindFunction) {
        return utils_1.getNodeByNameOrFindFunction(this.getMembers(), nameOrFindFunction);
    }
    getMemberOrThrow(nameOrFindFunction) {
        return errors.throwIfNullOrUndefined(this.getMember(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("enum member", nameOrFindFunction));
    }
    /**
     * Gets the enum's members.
     */
    getMembers() {
        return this.compilerNode.members.map(m => this._getNodeFromCompilerNode(m));
    }
    /**
     * Gets the enum's members with comment enum members.
     */
    getMembersWithComments() {
        const compilerNode = this.compilerNode;
        return utils_2.ExtendedParser.getContainerArray(compilerNode, this.getSourceFile().compilerNode)
            .map(m => this._getNodeFromCompilerNode(m));
    }
    /**
     * Toggle if it's a const enum.
     */
    setIsConstEnum(value) {
        return this.toggleModifier("const", value);
    }
    /**
     * Gets if it's a const enum.
     */
    isConstEnum() {
        return this.getConstKeyword() != null;
    }
    /**
     * Gets the const enum keyword or undefined if not exists.
     */
    getConstKeyword() {
        return this.getFirstModifierByKind(typescript_1.SyntaxKind.ConstKeyword);
    }
    /**
     * Gets the structure equivalent to this node.
     */
    getStructure() {
        return callBaseGetStructure_1.callBaseGetStructure(exports.EnumDeclarationBase.prototype, this, {
            kind: structures_1.StructureKind.Enum,
            isConst: this.isConstEnum(),
            members: this.getMembers().map(member => member.getStructure())
        });
    }
}
exports.EnumDeclaration = EnumDeclaration;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = require("../../../../typescript");
const errors = require("../../../../errors");
const manipulation_1 = require("../../../../manipulation");
const structures_1 = require("../../../../structures");
const utils_1 = require("../../../../utils");
const base_1 = require("../../base");
const utils_2 = require("../../utils");
const MethodDeclaration_1 = require("../MethodDeclaration");
const AbstractableNode_1 = require("./AbstractableNode");
function ClassLikeDeclarationBase(Base) {
    return ClassLikeDeclarationBaseSpecific(base_1.NameableNode(base_1.TextInsertableNode(base_1.ImplementsClauseableNode(base_1.HeritageClauseableNode(AbstractableNode_1.AbstractableNode(base_1.JSDocableNode(base_1.TypeParameteredNode(base_1.DecoratableNode(base_1.ModifierableNode(Base))))))))));
}
exports.ClassLikeDeclarationBase = ClassLikeDeclarationBase;
function ClassLikeDeclarationBaseSpecific(Base) {
    return class extends Base {
        setExtends(text) {
            text = this._getTextWithQueuedChildIndentation(text);
            if (utils_1.StringUtils.isNullOrWhitespace(text))
                return this.removeExtends();
            const extendsClause = this.getHeritageClauseByKind(typescript_1.SyntaxKind.ExtendsKeyword);
            if (extendsClause != null) {
                const childSyntaxList = extendsClause.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.SyntaxList);
                const childSyntaxListStart = childSyntaxList.getStart();
                manipulation_1.insertIntoParentTextRange({
                    parent: extendsClause,
                    newText: text,
                    insertPos: childSyntaxListStart,
                    replacing: {
                        textLength: childSyntaxList.getEnd() - childSyntaxListStart
                    }
                });
            }
            else {
                const implementsClause = this.getHeritageClauseByKind(typescript_1.SyntaxKind.ImplementsKeyword);
                let insertPos;
                if (implementsClause != null)
                    insertPos = implementsClause.getStart();
                else
                    insertPos = this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.OpenBraceToken).getStart();
                const isLastSpace = /\s/.test(this.getSourceFile().getFullText()[insertPos - 1]);
                let newText = `extends ${text} `;
                if (!isLastSpace)
                    newText = " " + newText;
                manipulation_1.insertIntoParentTextRange({
                    parent: implementsClause == null ? this : implementsClause.getParentSyntaxListOrThrow(),
                    insertPos,
                    newText
                });
            }
            return this;
        }
        removeExtends() {
            const extendsClause = this.getHeritageClauseByKind(typescript_1.SyntaxKind.ExtendsKeyword);
            if (extendsClause == null)
                return this;
            extendsClause.removeExpression(0);
            return this;
        }
        getExtendsOrThrow() {
            return errors.throwIfNullOrUndefined(this.getExtends(), `Expected to find the extends expression for the class ${this.getName()}.`);
        }
        getExtends() {
            const extendsClause = this.getHeritageClauseByKind(typescript_1.SyntaxKind.ExtendsKeyword);
            if (extendsClause == null)
                return undefined;
            const types = extendsClause.getTypeNodes();
            return types.length === 0 ? undefined : types[0];
        }
        addMembers(members) {
            return this.insertMembers(manipulation_1.getEndIndexFromArray(this.getMembersWithComments()), members);
        }
        addMember(member) {
            return this.insertMember(manipulation_1.getEndIndexFromArray(this.getMembersWithComments()), member);
        }
        insertMember(index, member) {
            return this.insertMembers(index, [member])[0];
        }
        insertMembers(index, members) {
            const isAmbient = utils_1.isNodeAmbientOrInAmbientContext(this);
            return manipulation_1.insertIntoBracesOrSourceFileWithGetChildrenWithComments({
                getIndexedChildren: () => this.getMembersWithComments(),
                index,
                parent: this,
                write: (writer, info) => {
                    const previousMemberHasBody = !isAmbient && info.previousMember != null && utils_1.TypeGuards.isBodyableNode(info.previousMember) && info.previousMember.hasBody();
                    const firstStructureHasBody = !isAmbient && members instanceof Array && structureHasBody(members[0]);
                    if (previousMemberHasBody || info.previousMember != null && firstStructureHasBody)
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                    // create a new writer here because the class member printer will add a blank line in certain cases
                    // at the front if it's not on the first line of a block
                    const memberWriter = this._getWriter();
                    const memberPrinter = this._context.structurePrinterFactory.forClassMember({ isAmbient });
                    memberPrinter.printTexts(memberWriter, members);
                    writer.write(memberWriter.toString());
                    const lastStructureHasBody = !isAmbient && members instanceof Array && structureHasBody(members[members.length - 1]);
                    const nextMemberHasBody = !isAmbient && info.nextMember != null && utils_1.TypeGuards.isBodyableNode(info.nextMember) && info.nextMember.hasBody();
                    if (info.nextMember != null && lastStructureHasBody || nextMemberHasBody)
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                }
            });
            function structureHasBody(value) {
                if (isAmbient || value == null || typeof value.kind !== "number")
                    return false;
                const structure = value;
                return structures_1.StructureTypeGuards.isMethod(structure)
                    || structures_1.StructureTypeGuards.isGetAccessor(structure)
                    || structures_1.StructureTypeGuards.isSetAccessor(structure)
                    || structures_1.StructureTypeGuards.isConstructor(structure);
            }
        }
        addConstructor(structure = {}) {
            return this.insertConstructor(manipulation_1.getEndIndexFromArray(this.getMembersWithComments()), structure);
        }
        addConstructors(structures) {
            return this.insertConstructors(manipulation_1.getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertConstructor(index, structure = {}) {
            return this.insertConstructors(index, [structure])[0];
        }
        insertConstructors(index, structures) {
            const isAmbient = utils_1.isNodeAmbientOrInAmbientContext(this);
            return insertChildren(this, {
                index,
                structures,
                expectedKind: typescript_1.SyntaxKind.Constructor,
                write: (writer, info) => {
                    if (!isAmbient && info.previousMember != null)
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                    this._context.structurePrinterFactory.forConstructorDeclaration({ isAmbient }).printTexts(writer, structures);
                    if (!isAmbient && info.nextMember != null)
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                }
            });
        }
        getConstructors() {
            return this.getMembers().filter(m => utils_1.TypeGuards.isConstructorDeclaration(m));
        }
        addGetAccessor(structure) {
            return this.addGetAccessors([structure])[0];
        }
        addGetAccessors(structures) {
            return this.insertGetAccessors(manipulation_1.getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertGetAccessor(index, structure) {
            return this.insertGetAccessors(index, [structure])[0];
        }
        insertGetAccessors(index, structures) {
            return insertChildren(this, {
                index,
                structures,
                expectedKind: typescript_1.SyntaxKind.GetAccessor,
                write: (writer, info) => {
                    if (info.previousMember != null)
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                    this._context.structurePrinterFactory.forGetAccessorDeclaration({
                        isAmbient: utils_1.isNodeAmbientOrInAmbientContext(this)
                    }).printTexts(writer, structures);
                    if (info.nextMember != null)
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                }
            });
        }
        addSetAccessor(structure) {
            return this.addSetAccessors([structure])[0];
        }
        addSetAccessors(structures) {
            return this.insertSetAccessors(manipulation_1.getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertSetAccessor(index, structure) {
            return this.insertSetAccessors(index, [structure])[0];
        }
        insertSetAccessors(index, structures) {
            return insertChildren(this, {
                index,
                structures,
                expectedKind: typescript_1.SyntaxKind.SetAccessor,
                write: (writer, info) => {
                    if (info.previousMember != null)
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                    this._context.structurePrinterFactory.forSetAccessorDeclaration({
                        isAmbient: utils_1.isNodeAmbientOrInAmbientContext(this)
                    }).printTexts(writer, structures);
                    if (info.nextMember != null)
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                }
            });
        }
        addProperty(structure) {
            return this.addProperties([structure])[0];
        }
        addProperties(structures) {
            return this.insertProperties(manipulation_1.getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertProperty(index, structure) {
            return this.insertProperties(index, [structure])[0];
        }
        insertProperties(index, structures) {
            return insertChildren(this, {
                index,
                structures,
                expectedKind: typescript_1.SyntaxKind.PropertyDeclaration,
                write: (writer, info) => {
                    if (info.previousMember != null && utils_1.TypeGuards.hasBody(info.previousMember))
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                    this._context.structurePrinterFactory.forPropertyDeclaration().printTexts(writer, structures);
                    if (info.nextMember != null && utils_1.TypeGuards.hasBody(info.nextMember))
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                }
            });
        }
        addMethod(structure) {
            return this.addMethods([structure])[0];
        }
        addMethods(structures) {
            return this.insertMethods(manipulation_1.getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertMethod(index, structure) {
            return this.insertMethods(index, [structure])[0];
        }
        insertMethods(index, structures) {
            const isAmbient = utils_1.isNodeAmbientOrInAmbientContext(this);
            structures = structures.map(s => (Object.assign({}, s)));
            // insert, fill, and get created nodes
            return insertChildren(this, {
                index,
                write: (writer, info) => {
                    if (!isAmbient && info.previousMember != null)
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                    this._context.structurePrinterFactory.forMethodDeclaration({ isAmbient }).printTexts(writer, structures);
                    if (!isAmbient && info.nextMember != null)
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                },
                structures,
                expectedKind: typescript_1.SyntaxKind.MethodDeclaration
            });
        }
        getInstanceProperty(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getInstanceProperties(), nameOrFindFunction);
        }
        getInstancePropertyOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getInstanceProperty(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("class instance property", nameOrFindFunction));
        }
        getInstanceProperties() {
            return this.getInstanceMembers()
                .filter(m => isClassPropertyType(m));
        }
        getStaticProperty(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getStaticProperties(), nameOrFindFunction);
        }
        getStaticPropertyOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getStaticProperty(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("class static property", nameOrFindFunction));
        }
        getStaticProperties() {
            return this.getStaticMembers()
                .filter(m => isClassPropertyType(m));
        }
        getProperty(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getProperties(), nameOrFindFunction);
        }
        getPropertyOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getProperty(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("class property declaration", nameOrFindFunction));
        }
        getProperties() {
            return this.getMembers()
                .filter(m => utils_1.TypeGuards.isPropertyDeclaration(m));
        }
        getGetAccessor(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getGetAccessors(), nameOrFindFunction);
        }
        getGetAccessorOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getGetAccessor(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("class getAccessor declaration", nameOrFindFunction));
        }
        getGetAccessors() {
            return this.getMembers()
                .filter(m => utils_1.TypeGuards.isGetAccessorDeclaration(m));
        }
        getSetAccessor(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getSetAccessors(), nameOrFindFunction);
        }
        getSetAccessorOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getSetAccessor(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("class setAccessor declaration", nameOrFindFunction));
        }
        getSetAccessors() {
            return this.getMembers()
                .filter(m => utils_1.TypeGuards.isSetAccessorDeclaration(m));
        }
        getMethod(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getMethods(), nameOrFindFunction);
        }
        getMethodOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getMethod(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("class method declaration", nameOrFindFunction));
        }
        getMethods() {
            return this.getMembers()
                .filter(m => utils_1.TypeGuards.isMethodDeclaration(m));
        }
        getInstanceMethod(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getInstanceMethods(), nameOrFindFunction);
        }
        getInstanceMethodOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getInstanceMethod(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("class instance method", nameOrFindFunction));
        }
        getInstanceMethods() {
            return this.getInstanceMembers().filter(m => m instanceof MethodDeclaration_1.MethodDeclaration);
        }
        getStaticMethod(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getStaticMethods(), nameOrFindFunction);
        }
        getStaticMethodOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getStaticMethod(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("class static method", nameOrFindFunction));
        }
        getStaticMethods() {
            return this.getStaticMembers().filter(m => m instanceof MethodDeclaration_1.MethodDeclaration);
        }
        getInstanceMember(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getInstanceMembers(), nameOrFindFunction);
        }
        getInstanceMemberOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getInstanceMember(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("class instance member", nameOrFindFunction));
        }
        getInstanceMembers() {
            return this.getMembersWithParameterProperties().filter(m => {
                if (utils_1.TypeGuards.isConstructorDeclaration(m))
                    return false;
                return utils_1.TypeGuards.isParameterDeclaration(m) || !m.isStatic();
            });
        }
        getStaticMember(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getStaticMembers(), nameOrFindFunction);
        }
        getStaticMemberOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getStaticMember(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("class static member", nameOrFindFunction));
        }
        getStaticMembers() {
            return this.getMembers().filter(m => {
                if (utils_1.TypeGuards.isConstructorDeclaration(m))
                    return false;
                return !utils_1.TypeGuards.isParameterDeclaration(m) && m.isStatic();
            });
        }
        getMembersWithParameterProperties() {
            const members = this.getMembers();
            const implementationCtors = members.filter(c => utils_1.TypeGuards.isConstructorDeclaration(c) && c.isImplementation());
            for (const ctor of implementationCtors) {
                // insert after the constructor
                let insertIndex = members.indexOf(ctor) + 1;
                for (const param of ctor.getParameters()) {
                    if (param.isParameterProperty()) {
                        members.splice(insertIndex, 0, param);
                        insertIndex++;
                    }
                }
            }
            return members;
        }
        getMembers() {
            return getAllMembers(this, this.compilerNode.members).filter(m => isSupportedClassMember(m));
        }
        getMembersWithComments() {
            const compilerNode = this.compilerNode;
            const members = utils_2.ExtendedParser.getContainerArray(compilerNode, this.getSourceFile().compilerNode);
            return getAllMembers(this, members).filter(m => isSupportedClassMember(m) || utils_1.TypeGuards.isCommentClassElement(m));
        }
        getMember(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getMembers(), nameOrFindFunction);
        }
        getMemberOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getMember(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("class member", nameOrFindFunction));
        }
        getBaseTypes() {
            return this.getType().getBaseTypes();
        }
        getBaseClassOrThrow() {
            return errors.throwIfNullOrUndefined(this.getBaseClass(), `Expected to find the base class of ${this.getName()}.`);
        }
        getBaseClass() {
            const baseTypes = utils_1.ArrayUtils.flatten(this.getBaseTypes().map(t => t.isIntersection() ? t.getIntersectionTypes() : [t]));
            const declarations = baseTypes
                .map(t => t.getSymbol())
                .filter(s => s != null)
                .map(s => s.getDeclarations())
                .reduce((a, b) => a.concat(b), [])
                .filter(d => d.getKind() === typescript_1.SyntaxKind.ClassDeclaration);
            if (declarations.length !== 1)
                return undefined;
            return declarations[0];
        }
        getDerivedClasses() {
            const classes = getImmediateDerivedClasses(this);
            for (let i = 0; i < classes.length; i++) {
                const derivedClasses = getImmediateDerivedClasses(classes[i]);
                for (const derivedClass of derivedClasses) {
                    // don't allow circular references
                    if (derivedClass !== this && classes.indexOf(derivedClass) === -1)
                        classes.push(derivedClass);
                }
            }
            return classes;
        }
    };
}
exports.ClassLikeDeclarationBaseSpecific = ClassLikeDeclarationBaseSpecific;
function getAllMembers(classDec, compilerMembers) {
    const isAmbient = utils_1.isNodeAmbientOrInAmbientContext(classDec);
    // not sure why this cast is necessary, but localized it to here...
    const members = compilerMembers.map(m => classDec._getNodeFromCompilerNode(m));
    // filter out the method declarations or constructor declarations without a body if not ambient
    return isAmbient ? members : members.filter(m => {
        if (!(utils_1.TypeGuards.isConstructorDeclaration(m) || utils_1.TypeGuards.isMethodDeclaration(m)))
            return true;
        if (utils_1.TypeGuards.isMethodDeclaration(m) && m.isAbstract())
            return true;
        return m.isImplementation();
    });
}
function getImmediateDerivedClasses(classDec) {
    const classes = [];
    const nameNode = classDec.getNameNode();
    if (nameNode == null)
        return classes;
    for (const node of nameNode.findReferencesAsNodes()) {
        const nodeParent = node.getParentIfKind(typescript_1.SyntaxKind.ExpressionWithTypeArguments);
        if (nodeParent == null)
            continue;
        const heritageClause = nodeParent.getParentIfKind(typescript_1.SyntaxKind.HeritageClause);
        if (heritageClause == null || heritageClause.getToken() !== typescript_1.SyntaxKind.ExtendsKeyword)
            continue;
        const derivedClass = heritageClause.getParentIfKind(typescript_1.SyntaxKind.ClassDeclaration);
        if (derivedClass == null)
            continue;
        classes.push(derivedClass);
    }
    return classes;
}
function isClassPropertyType(m) {
    return utils_1.TypeGuards.isPropertyDeclaration(m)
        || utils_1.TypeGuards.isSetAccessorDeclaration(m)
        || utils_1.TypeGuards.isGetAccessorDeclaration(m)
        || utils_1.TypeGuards.isParameterDeclaration(m);
}
function isSupportedClassMember(m) {
    return utils_1.TypeGuards.isMethodDeclaration(m)
        || utils_1.TypeGuards.isPropertyDeclaration(m)
        || utils_1.TypeGuards.isGetAccessorDeclaration(m)
        || utils_1.TypeGuards.isSetAccessorDeclaration(m)
        || utils_1.TypeGuards.isConstructorDeclaration(m);
}
function insertChildren(classDeclaration, opts) {
    return manipulation_1.insertIntoBracesOrSourceFileWithGetChildren(Object.assign({ getIndexedChildren: () => classDeclaration.getMembersWithComments(), parent: classDeclaration }, opts));
}

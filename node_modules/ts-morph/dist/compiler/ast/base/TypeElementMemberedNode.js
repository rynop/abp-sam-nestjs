"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../../../errors");
const manipulation_1 = require("../../../manipulation");
const typescript_1 = require("../../../typescript");
const utils_1 = require("../../../utils");
const callBaseSet_1 = require("../callBaseSet");
const callBaseGetStructure_1 = require("../callBaseGetStructure");
const utils_2 = require("../utils");
function TypeElementMemberedNode(Base) {
    return class extends Base {
        addMember(member) {
            return this.addMembers([member])[0];
        }
        addMembers(members) {
            return this.insertMembers(manipulation_1.getEndIndexFromArray(this.getMembersWithComments()), members);
        }
        insertMember(index, member) {
            return this.insertMembers(index, [member])[0];
        }
        insertMembers(index, members) {
            return manipulation_1.insertIntoBracesOrSourceFileWithGetChildrenWithComments({
                getIndexedChildren: () => this.getMembersWithComments(),
                index,
                parent: this,
                write: writer => {
                    writer.newLineIfLastNot();
                    // create a new writer here because the class member printer will add a blank line in certain cases
                    // at the front if it's not on the first line of a block
                    const memberWriter = this._getWriter();
                    const memberPrinter = this._context.structurePrinterFactory.forTypeElementMember();
                    memberPrinter.printTexts(memberWriter, members);
                    writer.write(memberWriter.toString());
                    writer.newLineIfLastNot();
                }
            });
        }
        addConstructSignature(structure) {
            return this.addConstructSignatures([structure])[0];
        }
        addConstructSignatures(structures) {
            return this.insertConstructSignatures(manipulation_1.getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertConstructSignature(index, structure) {
            return this.insertConstructSignatures(index, [structure])[0];
        }
        insertConstructSignatures(index, structures) {
            return insertChildren({
                thisNode: this,
                index,
                structures,
                expectedKind: typescript_1.SyntaxKind.ConstructSignature,
                createStructurePrinter: () => this._context.structurePrinterFactory.forConstructSignatureDeclaration()
            });
        }
        getConstructSignature(findFunction) {
            return this.getConstructSignatures().find(findFunction);
        }
        getConstructSignatureOrThrow(findFunction) {
            return errors.throwIfNullOrUndefined(this.getConstructSignature(findFunction), "Expected to find a construct signature with the provided condition.");
        }
        getConstructSignatures() {
            return this.compilerNode.members.filter(m => m.kind === typescript_1.SyntaxKind.ConstructSignature)
                .map(m => this._getNodeFromCompilerNode(m));
        }
        addCallSignature(structure) {
            return this.addCallSignatures([structure])[0];
        }
        addCallSignatures(structures) {
            return this.insertCallSignatures(manipulation_1.getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertCallSignature(index, structure) {
            return this.insertCallSignatures(index, [structure])[0];
        }
        insertCallSignatures(index, structures) {
            return insertChildren({
                thisNode: this,
                index,
                structures,
                expectedKind: typescript_1.SyntaxKind.CallSignature,
                createStructurePrinter: () => this._context.structurePrinterFactory.forCallSignatureDeclaration()
            });
        }
        getCallSignature(findFunction) {
            return this.getCallSignatures().find(findFunction);
        }
        getCallSignatureOrThrow(findFunction) {
            return errors.throwIfNullOrUndefined(this.getCallSignature(findFunction), "Expected to find a call signature with the provided condition.");
        }
        getCallSignatures() {
            return this.compilerNode.members.filter(m => m.kind === typescript_1.SyntaxKind.CallSignature)
                .map(m => this._getNodeFromCompilerNode(m));
        }
        addIndexSignature(structure) {
            return this.addIndexSignatures([structure])[0];
        }
        addIndexSignatures(structures) {
            return this.insertIndexSignatures(manipulation_1.getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertIndexSignature(index, structure) {
            return this.insertIndexSignatures(index, [structure])[0];
        }
        insertIndexSignatures(index, structures) {
            return insertChildren({
                thisNode: this,
                index,
                structures,
                expectedKind: typescript_1.SyntaxKind.IndexSignature,
                createStructurePrinter: () => this._context.structurePrinterFactory.forIndexSignatureDeclaration()
            });
        }
        getIndexSignature(findFunction) {
            return this.getIndexSignatures().find(findFunction);
        }
        getIndexSignatureOrThrow(findFunction) {
            return errors.throwIfNullOrUndefined(this.getIndexSignature(findFunction), "Expected to find a index signature with the provided condition.");
        }
        getIndexSignatures() {
            return this.compilerNode.members.filter(m => m.kind === typescript_1.SyntaxKind.IndexSignature)
                .map(m => this._getNodeFromCompilerNode(m));
        }
        addMethod(structure) {
            return this.addMethods([structure])[0];
        }
        addMethods(structures) {
            return this.insertMethods(manipulation_1.getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertMethod(index, structure) {
            return this.insertMethods(index, [structure])[0];
        }
        insertMethods(index, structures) {
            return insertChildren({
                thisNode: this,
                index,
                structures,
                expectedKind: typescript_1.SyntaxKind.MethodSignature,
                createStructurePrinter: () => this._context.structurePrinterFactory.forMethodSignature()
            });
        }
        getMethod(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getMethods(), nameOrFindFunction);
        }
        getMethodOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getMethod(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("interface method signature", nameOrFindFunction));
        }
        getMethods() {
            return this.compilerNode.members.filter(m => m.kind === typescript_1.SyntaxKind.MethodSignature)
                .map(m => this._getNodeFromCompilerNode(m));
        }
        addProperty(structure) {
            return this.addProperties([structure])[0];
        }
        addProperties(structures) {
            return this.insertProperties(manipulation_1.getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertProperty(index, structure) {
            return this.insertProperties(index, [structure])[0];
        }
        insertProperties(index, structures) {
            return insertChildren({
                thisNode: this,
                index,
                structures,
                expectedKind: typescript_1.SyntaxKind.PropertySignature,
                createStructurePrinter: () => this._context.structurePrinterFactory.forPropertySignature()
            });
        }
        getProperty(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getProperties(), nameOrFindFunction);
        }
        getPropertyOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getProperty(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("interface property signature", nameOrFindFunction));
        }
        getProperties() {
            return this.compilerNode.members.filter(m => m.kind === typescript_1.SyntaxKind.PropertySignature)
                .map(m => this._getNodeFromCompilerNode(m));
        }
        getMembers() {
            return this.compilerNode.members.map(m => this._getNodeFromCompilerNode(m));
        }
        getMembersWithComments() {
            const compilerNode = this.compilerNode;
            return utils_2.ExtendedParser.getContainerArray(compilerNode, this._sourceFile.compilerNode)
                .map(m => this._getNodeFromCompilerNode(m));
        }
        set(structure) {
            callBaseSet_1.callBaseSet(Base.prototype, this, structure);
            if (structure.callSignatures != null) {
                this.getCallSignatures().forEach(c => c.remove());
                this.addCallSignatures(structure.callSignatures);
            }
            if (structure.constructSignatures != null) {
                this.getConstructSignatures().forEach(c => c.remove());
                this.addConstructSignatures(structure.constructSignatures);
            }
            if (structure.indexSignatures != null) {
                this.getIndexSignatures().forEach(c => c.remove());
                this.addIndexSignatures(structure.indexSignatures);
            }
            if (structure.properties != null) {
                this.getProperties().forEach(c => c.remove());
                this.addProperties(structure.properties);
            }
            if (structure.methods != null) {
                this.getMethods().forEach(c => c.remove());
                this.addMethods(structure.methods);
            }
            return this;
        }
        getStructure() {
            return callBaseGetStructure_1.callBaseGetStructure(Base.prototype, this, {
                callSignatures: this.getCallSignatures().map(node => node.getStructure()),
                constructSignatures: this.getConstructSignatures().map(node => node.getStructure()),
                indexSignatures: this.getIndexSignatures().map(node => node.getStructure()),
                methods: this.getMethods().map(node => node.getStructure()),
                properties: this.getProperties().map(node => node.getStructure())
            });
        }
    };
}
exports.TypeElementMemberedNode = TypeElementMemberedNode;
function insertChildren(opts) {
    return manipulation_1.insertIntoBracesOrSourceFileWithGetChildren({
        getIndexedChildren: () => opts.thisNode.getMembersWithComments(),
        parent: opts.thisNode,
        index: opts.index,
        structures: opts.structures,
        expectedKind: opts.expectedKind,
        write: (writer, info) => {
            writer.newLineIfLastNot();
            opts.createStructurePrinter().printTexts(writer, opts.structures);
            writer.newLineIfLastNot();
        }
    });
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../../../errors");
const manipulation_1 = require("../../../manipulation");
const typescript_1 = require("../../../typescript");
const utils_1 = require("../../../utils");
const callBaseSet_1 = require("../callBaseSet");
const callBaseGetStructure_1 = require("../callBaseGetStructure");
const utils_2 = require("../utils");
function StatementedNode(Base) {
    return class extends Base {
        /* General */
        getStatements() {
            const statementsContainer = this._getCompilerStatementsContainer();
            const statements = statementsContainer == null
                ? []
                : statementsContainer.statements;
            return statements.map(s => this._getNodeFromCompilerNode(s));
        }
        getStatementsWithComments() {
            return this._getCompilerStatementsWithComments().map(s => this._getNodeFromCompilerNode(s));
        }
        getStatement(findFunction) {
            return this.getStatements().find(findFunction);
        }
        getStatementOrThrow(findFunction) {
            return errors.throwIfNullOrUndefined(this.getStatement(findFunction), "Expected to find a statement matching the provided condition.");
        }
        getStatementByKind(kind) {
            const statement = this._getCompilerStatementsWithComments().find(s => s.kind === kind);
            return this._getNodeFromCompilerNodeIfExists(statement);
        }
        getStatementByKindOrThrow(kind) {
            return errors.throwIfNullOrUndefined(this.getStatementByKind(kind), `Expected to find a statement with syntax kind ${utils_1.getSyntaxKindName(kind)}.`);
        }
        addStatements(textOrWriterFunction) {
            return this.insertStatements(this._getCompilerStatementsWithComments().length, textOrWriterFunction);
        }
        insertStatements(index, statements) {
            addBodyIfNotExists(this);
            const writerFunction = (writer) => {
                const statementsPrinter = this._context.structurePrinterFactory.forStatement({ isAmbient: utils_1.isNodeAmbientOrInAmbientContext(this) });
                statementsPrinter.printTexts(writer, statements);
            };
            return getChildSyntaxList.call(this).insertChildText(index, writerFunction);
            function getChildSyntaxList() {
                const childSyntaxList = this.getChildSyntaxListOrThrow();
                // case and default clauses can optionally have blocks
                if (utils_1.TypeGuards.isCaseClause(this) || utils_1.TypeGuards.isDefaultClause(this)) {
                    const block = childSyntaxList.getFirstChildIfKind(typescript_1.SyntaxKind.Block);
                    if (block != null)
                        return block.getChildSyntaxListOrThrow();
                }
                return childSyntaxList;
            }
        }
        removeStatement(index) {
            index = manipulation_1.verifyAndGetIndex(index, this._getCompilerStatementsWithComments().length - 1);
            return this.removeStatements([index, index]);
        }
        removeStatements(indexRange) {
            const statements = this.getStatementsWithComments();
            errors.throwIfRangeOutOfRange(indexRange, [0, statements.length], "indexRange");
            manipulation_1.removeStatementedNodeChildren(statements.slice(indexRange[0], indexRange[1] + 1));
            return this;
        }
        /* Classes */
        addClass(structure) {
            return this.addClasses([structure])[0];
        }
        addClasses(structures) {
            return this.insertClasses(this._getCompilerStatementsWithComments().length, structures);
        }
        insertClass(index, structure) {
            return this.insertClasses(index, [structure])[0];
        }
        insertClasses(index, structures) {
            return this._insertChildren({
                expectedKind: typescript_1.SyntaxKind.ClassDeclaration,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forClassDeclaration({ isAmbient: utils_1.isNodeAmbientOrInAmbientContext(this) }).printTexts(writer, structures);
                    });
                }
            });
        }
        getClasses() {
            return this.getStatements().filter(utils_1.TypeGuards.isClassDeclaration);
        }
        getClass(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getClasses(), nameOrFindFunction);
        }
        getClassOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getClass(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("class", nameOrFindFunction));
        }
        /* Enums */
        addEnum(structure) {
            return this.addEnums([structure])[0];
        }
        addEnums(structures) {
            return this.insertEnums(this._getCompilerStatementsWithComments().length, structures);
        }
        insertEnum(index, structure) {
            return this.insertEnums(index, [structure])[0];
        }
        insertEnums(index, structures) {
            return this._insertChildren({
                expectedKind: typescript_1.SyntaxKind.EnumDeclaration,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forEnumDeclaration().printTexts(writer, structures);
                    });
                }
            });
        }
        getEnums() {
            return this.getStatements().filter(utils_1.TypeGuards.isEnumDeclaration);
        }
        getEnum(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getEnums(), nameOrFindFunction);
        }
        getEnumOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getEnum(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("enum", nameOrFindFunction));
        }
        /* Functions */
        addFunction(structure) {
            return this.addFunctions([structure])[0];
        }
        addFunctions(structures) {
            return this.insertFunctions(this._getCompilerStatementsWithComments().length, structures);
        }
        insertFunction(index, structure) {
            return this.insertFunctions(index, [structure])[0];
        }
        insertFunctions(index, structures) {
            return this._insertChildren({
                expectedKind: typescript_1.SyntaxKind.FunctionDeclaration,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forFunctionDeclaration({
                            isAmbient: utils_1.isNodeAmbientOrInAmbientContext(this)
                        }).printTexts(writer, structures);
                    }, {
                        previousNewLine: previousMember => structures[0].hasDeclareKeyword === true && utils_1.TypeGuards.isFunctionDeclaration(previousMember) && previousMember.getBody() == null,
                        nextNewLine: nextMember => structures[structures.length - 1].hasDeclareKeyword === true && utils_1.TypeGuards.isFunctionDeclaration(nextMember) && nextMember.getBody() == null
                    });
                }
            });
        }
        getFunctions() {
            return this.getStatements().filter(utils_1.TypeGuards.isFunctionDeclaration).filter(f => f.isAmbient() || f.isImplementation());
        }
        getFunction(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getFunctions(), nameOrFindFunction);
        }
        getFunctionOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getFunction(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("function", nameOrFindFunction));
        }
        /* Interfaces */
        addInterface(structure) {
            return this.addInterfaces([structure])[0];
        }
        addInterfaces(structures) {
            return this.insertInterfaces(this._getCompilerStatementsWithComments().length, structures);
        }
        insertInterface(index, structure) {
            return this.insertInterfaces(index, [structure])[0];
        }
        insertInterfaces(index, structures) {
            return this._insertChildren({
                expectedKind: typescript_1.SyntaxKind.InterfaceDeclaration,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forInterfaceDeclaration().printTexts(writer, structures);
                    });
                }
            });
        }
        getInterfaces() {
            return this.getStatements().filter(utils_1.TypeGuards.isInterfaceDeclaration);
        }
        getInterface(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getInterfaces(), nameOrFindFunction);
        }
        getInterfaceOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getInterface(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("interface", nameOrFindFunction));
        }
        /* Namespaces */
        addNamespace(structure) {
            return this.addNamespaces([structure])[0];
        }
        addNamespaces(structures) {
            return this.insertNamespaces(this._getCompilerStatementsWithComments().length, structures);
        }
        insertNamespace(index, structure) {
            return this.insertNamespaces(index, [structure])[0];
        }
        insertNamespaces(index, structures) {
            return this._insertChildren({
                expectedKind: typescript_1.SyntaxKind.ModuleDeclaration,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forNamespaceDeclaration({ isAmbient: utils_1.isNodeAmbientOrInAmbientContext(this) }).printTexts(writer, structures);
                    });
                }
            });
        }
        getNamespaces() {
            return this.getStatements().filter(utils_1.TypeGuards.isNamespaceDeclaration);
        }
        getNamespace(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getNamespaces(), nameOrFindFunction);
        }
        getNamespaceOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getNamespace(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("namespace", nameOrFindFunction));
        }
        /* Type aliases */
        addTypeAlias(structure) {
            return this.addTypeAliases([structure])[0];
        }
        addTypeAliases(structures) {
            return this.insertTypeAliases(this._getCompilerStatementsWithComments().length, structures);
        }
        insertTypeAlias(index, structure) {
            return this.insertTypeAliases(index, [structure])[0];
        }
        insertTypeAliases(index, structures) {
            return this._insertChildren({
                expectedKind: typescript_1.SyntaxKind.TypeAliasDeclaration,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forTypeAliasDeclaration().printTexts(writer, structures);
                    }, {
                        previousNewLine: previousMember => utils_1.TypeGuards.isTypeAliasDeclaration(previousMember),
                        nextNewLine: nextMember => utils_1.TypeGuards.isTypeAliasDeclaration(nextMember)
                    });
                }
            });
        }
        getTypeAliases() {
            return this.getStatements().filter(utils_1.TypeGuards.isTypeAliasDeclaration);
        }
        getTypeAlias(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getTypeAliases(), nameOrFindFunction);
        }
        getTypeAliasOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getTypeAlias(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("type alias", nameOrFindFunction));
        }
        /* Variable statements */
        getVariableStatements() {
            return this.getStatements().filter(utils_1.TypeGuards.isVariableStatement);
        }
        getVariableStatement(nameOrFindFunction) {
            return this.getVariableStatements().find(getFindFunction());
            function getFindFunction() {
                if (typeof nameOrFindFunction === "string")
                    return (statement) => statement.getDeclarations().some(d => utils_1.nodeHasName(d, nameOrFindFunction));
                return nameOrFindFunction;
            }
        }
        getVariableStatementOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getVariableStatement(nameOrFindFunction), "Expected to find a variable statement that matched the provided condition.");
        }
        addVariableStatement(structure) {
            return this.addVariableStatements([structure])[0];
        }
        addVariableStatements(structures) {
            return this.insertVariableStatements(this._getCompilerStatementsWithComments().length, structures);
        }
        insertVariableStatement(index, structure) {
            return this.insertVariableStatements(index, [structure])[0];
        }
        insertVariableStatements(index, structures) {
            return this._insertChildren({
                expectedKind: typescript_1.SyntaxKind.VariableStatement,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forVariableStatement().printTexts(writer, structures);
                    }, {
                        previousNewLine: previousMember => utils_1.TypeGuards.isVariableStatement(previousMember),
                        nextNewLine: nextMember => utils_1.TypeGuards.isVariableStatement(nextMember)
                    });
                }
            });
        }
        /* Variable declarations */
        getVariableDeclarations() {
            const variables = [];
            for (const list of this.getVariableStatements())
                variables.push(...list.getDeclarations());
            return variables;
        }
        getVariableDeclaration(nameOrFindFunction) {
            return utils_1.getNodeByNameOrFindFunction(this.getVariableDeclarations(), nameOrFindFunction);
        }
        getVariableDeclarationOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getVariableDeclaration(nameOrFindFunction), () => utils_1.getNotFoundErrorMessageForNameOrFindFunction("variable declaration", nameOrFindFunction));
        }
        getStructure() {
            const structure = {};
            if (utils_1.TypeGuards.isBodyableNode(this) && !this.hasBody())
                structure.statements = undefined;
            else {
                structure.statements = this.getStatements().map(s => {
                    if (utils_1.TypeGuards._hasStructure(s))
                        return s.getStructure(); // todo: resolve this
                    return s.getText({ trimLeadingIndentation: true });
                });
            }
            return callBaseGetStructure_1.callBaseGetStructure(Base.prototype, this, structure);
        }
        set(structure) {
            // todo: I don't think it's necessary to do this in two steps anymore and this could probably
            // be changed to set the body text in one go instead (for performance reasons)
            if (utils_1.TypeGuards.isBodyableNode(this) && structure.statements == null && structure.hasOwnProperty("statements")) {
                this.removeBody();
            }
            else if (structure.statements != null) {
                const statementCount = this._getCompilerStatementsWithComments().length;
                if (statementCount > 0)
                    this.removeStatements([0, statementCount - 1]);
            }
            callBaseSet_1.callBaseSet(Base.prototype, this, structure);
            // add the text after if necessary
            if (structure.statements != null)
                this.addStatements(structure.statements);
            return this;
        }
        _getCompilerStatementsWithComments() {
            const statementsContainer = this._getCompilerStatementsContainer();
            if (statementsContainer == null)
                return [];
            else {
                // will always return an array of statements
                return utils_2.ExtendedParser.getContainerArray(statementsContainer, this._sourceFile.compilerNode);
            }
        }
        _getCompilerStatementsContainer() {
            if (utils_1.TypeGuards.isSourceFile(this) || utils_1.TypeGuards.isCaseClause(this) || utils_1.TypeGuards.isDefaultClause(this))
                return this.compilerNode;
            else if (utils_1.TypeGuards.isNamespaceDeclaration(this)) {
                // need to get the inner-most body for namespaces
                return this._getInnerBody().compilerNode;
            }
            else if (utils_1.TypeGuards.isBodyableNode(this)) {
                const body = this.getBody();
                if (body == null)
                    return undefined;
                return body.compilerNode;
            }
            else if (utils_1.TypeGuards.isBodiedNode(this)) {
                return this.getBody().compilerNode;
            }
            else if (utils_1.TypeGuards.isBlock(this) || utils_1.TypeGuards.isModuleBlock(this))
                return this.compilerNode;
            else
                throw new errors.NotImplementedError(`Could not find the statements for node kind: ${this.getKindName()}, text: ${this.getText()}`);
        }
        _insertChildren(opts) {
            addBodyIfNotExists(this);
            return manipulation_1.insertIntoBracesOrSourceFileWithGetChildren({
                expectedKind: opts.expectedKind,
                getIndexedChildren: () => this.getStatementsWithComments(),
                index: opts.index,
                parent: this,
                structures: opts.structures,
                write: (writer, info) => opts.write(writer, info)
            });
        }
        _standardWrite(writer, info, writeStructures, opts = {}) {
            if (info.previousMember != null && (opts.previousNewLine == null || !opts.previousNewLine(info.previousMember)))
                writer.blankLine();
            else if (!info.isStartOfFile)
                writer.newLineIfLastNot();
            writeStructures();
            if (info.nextMember != null && (opts.nextNewLine == null || !opts.nextNewLine(info.nextMember)))
                writer.blankLine();
            else
                writer.newLineIfLastNot();
        }
    };
}
exports.StatementedNode = StatementedNode;
function addBodyIfNotExists(node) {
    if (utils_1.TypeGuards.isBodyableNode(node) && !node.hasBody())
        node.addBody();
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = require("../../../typescript");
const errors = require("../../../errors");
const utils_1 = require("../../../utils");
const CompilerComments_1 = require("../comment/CompilerComments");
var CommentKind;
(function (CommentKind) {
    CommentKind[CommentKind["SingleLine"] = 0] = "SingleLine";
    CommentKind[CommentKind["MultiLine"] = 1] = "MultiLine";
    CommentKind[CommentKind["JsDoc"] = 2] = "JsDoc";
})(CommentKind || (CommentKind = {}));
const childrenSaver = new WeakMap();
const extendedCommentParserKinds = new Set([
    typescript_1.SyntaxKind.SourceFile,
    typescript_1.SyntaxKind.Block,
    typescript_1.SyntaxKind.ModuleBlock,
    typescript_1.SyntaxKind.CaseClause,
    typescript_1.SyntaxKind.DefaultClause,
    typescript_1.SyntaxKind.ClassDeclaration,
    typescript_1.SyntaxKind.InterfaceDeclaration,
    typescript_1.SyntaxKind.EnumDeclaration,
    typescript_1.SyntaxKind.ClassExpression,
    typescript_1.SyntaxKind.TypeLiteral,
    typescript_1.SyntaxKind.ObjectLiteralExpression
]);
class CommentNodeParser {
    constructor() {
    }
    static getOrParseChildren(container, sourceFile) {
        // always store the syntax list result on the parent so that a second array isn't created
        if (isSyntaxList(container))
            container = container.parent;
        // cache the result
        let children = childrenSaver.get(container);
        if (children == null) {
            children = Array.from(getNodes(container, sourceFile));
            childrenSaver.set(container, children);
        }
        return children;
    }
    static shouldParseChildren(container) {
        // this needs to be really fast because it's used whenever getting the children, so use a map
        return extendedCommentParserKinds.has(container.kind)
            // Ignore zero length nodes... for some reason this might happen when parsing
            // jsx in non-jsx files.
            && container.pos !== container.end;
    }
    static hasParsedChildren(container) {
        if (isSyntaxList(container))
            container = container.parent;
        return childrenSaver.has(container);
    }
    static isCommentStatement(node) {
        return node._commentKind === CompilerComments_1.CommentNodeKind.Statement;
    }
    static isCommentClassElement(node) {
        return node._commentKind === CompilerComments_1.CommentNodeKind.ClassElement;
    }
    static isCommentTypeElement(node) {
        return node._commentKind === CompilerComments_1.CommentNodeKind.TypeElement;
    }
    static isCommentObjectLiteralElement(node) {
        return node._commentKind === CompilerComments_1.CommentNodeKind.ObjectLiteralElement;
    }
    static isCommentEnumMember(node) {
        return node._commentKind === CompilerComments_1.CommentNodeKind.EnumMember;
    }
    static getContainerBodyPos(container, sourceFile) {
        if (typescript_1.ts.isSourceFile(container))
            return 0;
        if (typescript_1.ts.isClassDeclaration(container)
            || typescript_1.ts.isEnumDeclaration(container)
            || typescript_1.ts.isInterfaceDeclaration(container)
            || typescript_1.ts.isTypeLiteralNode(container)
            || typescript_1.ts.isClassExpression(container)
            || typescript_1.ts.isBlock(container)
            || typescript_1.ts.isModuleBlock(container)
            || typescript_1.ts.isObjectLiteralExpression(container)) {
            // this function is only used when there are no statements or members, so only do this
            return getTokenEnd(container, typescript_1.SyntaxKind.OpenBraceToken);
        }
        if (typescript_1.ts.isCaseClause(container) || typescript_1.ts.isDefaultClause(container))
            return getTokenEnd(container, typescript_1.SyntaxKind.ColonToken);
        return errors.throwNotImplementedForNeverValueError(container);
        function getTokenEnd(node, kind) {
            // @code-fence-allow(getChildren): Ok, not searching for comments.
            const token = node.getChildren(sourceFile).find(c => c.kind === kind);
            if (token == null)
                throw new errors.NotImplementedError(`Unexpected scenario where a(n) ${utils_1.getSyntaxKindName(kind)} was not found.`);
            return token.end;
        }
    }
}
exports.CommentNodeParser = CommentNodeParser;
function* getNodes(container, sourceFile) {
    const sourceFileText = sourceFile.text;
    const childNodes = getContainerChildren();
    const createComment = getCreationFunction();
    if (childNodes.length === 0) {
        const bodyStartPos = CommentNodeParser.getContainerBodyPos(container, sourceFile);
        yield* getExtendedComments(bodyStartPos, false); // do not skip js docs because they won't have a node to be attached to
    }
    else {
        for (const childNode of childNodes) {
            yield* getExtendedComments(childNode.pos, true);
            yield childNode;
        }
        // get the comments on a newline after the last node
        const lastChild = childNodes[childNodes.length - 1];
        yield* getExtendedComments(lastChild.end, false); // parse any jsdocs afterwards
    }
    function* getExtendedComments(pos, stopAtJsDoc) {
        const fullStart = pos;
        skipTrailingLine();
        const leadingComments = Array.from(getLeadingComments());
        // `pos` will be at the first significant token of the next node or at the source file length.
        // At this point, allow comments that end at the end of the source file or on the same line as the close brace token
        const maxEnd = sourceFileText.length === pos || sourceFileText[pos] === "}" ? pos : utils_1.StringUtils.getLineStartFromPos(sourceFileText, pos);
        for (const leadingComment of leadingComments) {
            if (leadingComment.end <= maxEnd)
                yield leadingComment;
        }
        function skipTrailingLine() {
            // skip first line of the block as the comment there is likely to describe the header
            if (pos === 0)
                return;
            let lineEnd = utils_1.StringUtils.getLineEndFromPos(sourceFileText, pos);
            while (pos < lineEnd) {
                const commentKind = getCommentKind();
                if (commentKind != null) {
                    const comment = parseForComment(commentKind);
                    if (comment.kind === typescript_1.SyntaxKind.SingleLineCommentTrivia)
                        return;
                    else
                        lineEnd = utils_1.StringUtils.getLineEndFromPos(sourceFileText, pos);
                }
                else if (!utils_1.StringUtils.isWhitespace(sourceFileText[pos]) && sourceFileText[pos] !== ",") // skip any trailing comments too
                    return;
                else
                    pos++;
            }
            while (utils_1.StringUtils.startsWithNewLine(sourceFileText[pos]))
                pos++;
        }
        function* getLeadingComments() {
            while (pos < sourceFileText.length) {
                const commentKind = getCommentKind();
                if (commentKind != null) {
                    const isJsDoc = commentKind === CommentKind.JsDoc;
                    if (isJsDoc && stopAtJsDoc)
                        return;
                    else
                        yield parseForComment(commentKind);
                    // treat comments on same line as trailing
                    skipTrailingLine();
                }
                else if (!utils_1.StringUtils.isWhitespace(sourceFileText[pos]))
                    return;
                else
                    pos++;
            }
        }
        function parseForComment(commentKind) {
            if (commentKind === CommentKind.SingleLine)
                return parseSingleLineComment();
            const isJsDoc = commentKind === CommentKind.JsDoc;
            return parseMultiLineComment(isJsDoc);
        }
        function getCommentKind() {
            const currentChar = sourceFileText[pos];
            if (currentChar !== "/")
                return undefined;
            const nextChar = sourceFileText[pos + 1];
            if (nextChar === "/")
                return CommentKind.SingleLine;
            if (nextChar !== "*")
                return undefined;
            const nextNextChar = sourceFileText[pos + 2];
            return nextNextChar === "*" ? CommentKind.JsDoc : CommentKind.MultiLine;
        }
        function parseSingleLineComment() {
            const start = pos;
            skipSingleLineComment();
            const end = pos;
            return createComment(fullStart, start, end, typescript_1.SyntaxKind.SingleLineCommentTrivia);
        }
        function skipSingleLineComment() {
            pos += 2; // skip the slash slash
            while (pos < sourceFileText.length && sourceFileText[pos] !== "\n" && sourceFileText[pos] !== "\r")
                pos++;
        }
        function parseMultiLineComment(isJsDoc) {
            const start = pos;
            skipSlashStarComment(isJsDoc);
            const end = pos;
            return createComment(fullStart, start, end, typescript_1.SyntaxKind.MultiLineCommentTrivia);
        }
        function skipSlashStarComment(isJsDoc) {
            pos += isJsDoc ? 3 : 2; // skip slash star star or slash star
            while (pos < sourceFileText.length) {
                if (sourceFileText[pos] === "*" && sourceFileText[pos + 1] === "/") {
                    pos += 2; // skip star slash
                    break;
                }
                pos++;
            }
        }
    }
    function getContainerChildren() {
        if (typescript_1.ts.isSourceFile(container) || typescript_1.ts.isBlock(container) || typescript_1.ts.isModuleBlock(container) || typescript_1.ts.isCaseClause(container) || typescript_1.ts.isDefaultClause(container))
            return container.statements;
        if (typescript_1.ts.isClassDeclaration(container)
            || typescript_1.ts.isClassExpression(container)
            || typescript_1.ts.isEnumDeclaration(container)
            || typescript_1.ts.isInterfaceDeclaration(container)
            || typescript_1.ts.isTypeLiteralNode(container)
            || typescript_1.ts.isClassExpression(container)) {
            return container.members;
        }
        if (typescript_1.ts.isObjectLiteralExpression(container))
            return container.properties;
        return errors.throwNotImplementedForNeverValueError(container);
    }
    function getCreationFunction() {
        const ctor = getCtor();
        return (fullStart, pos, end, kind) => new ctor(fullStart, pos, end, kind, sourceFile, container);
        function getCtor() {
            if (isStatementContainerNode(container))
                return CompilerComments_1.CompilerCommentStatement;
            if (typescript_1.ts.isClassLike(container))
                return CompilerComments_1.CompilerCommentClassElement;
            if (typescript_1.ts.isInterfaceDeclaration(container) || typescript_1.ts.isTypeLiteralNode(container))
                return CompilerComments_1.CompilerCommentTypeElement;
            if (typescript_1.ts.isObjectLiteralExpression(container))
                return CompilerComments_1.CompilerCommentObjectLiteralElement;
            if (typescript_1.ts.isEnumDeclaration(container))
                return CompilerComments_1.CompilerCommentEnumMember;
            throw new errors.NotImplementedError(`Not implemented comment node container type: ${utils_1.getSyntaxKindName(container.kind)}`);
        }
    }
}
function isSyntaxList(node) {
    return node.kind === typescript_1.SyntaxKind.SyntaxList;
}
function isStatementContainerNode(node) {
    return getStatementContainerNode() != null;
    function getStatementContainerNode() {
        // this is a bit of a hack so the type checker ensures this is correct
        const container = node;
        if (typescript_1.ts.isSourceFile(container)
            || typescript_1.ts.isBlock(container)
            || typescript_1.ts.isModuleBlock(container)
            || typescript_1.ts.isCaseClause(container)
            || typescript_1.ts.isDefaultClause(container)) {
            return container;
        }
        const assertNever = container;
        return undefined;
    }
}
